# chat_app

[1. Требования](https://github.com/amalkoott/chat_app/edit/master/README.md#1-%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
[2. Фреймворки и технологии](https://github.com/amalkoott/chat_app/edit/master/README.md#2-%D1%84%D1%80%D0%B5%D0%B9%D0%BC%D0%B2%D0%BE%D1%80%D0%BA%D0%B8-%D0%B8-%D1%82%D0%B5%D1%85%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D0%B8)
[3. Детали](https://github.com/amalkoott/chat_app/edit/master/README.md#3-%D0%B4%D0%B5%D1%82%D0%B0%D0%BB%D0%B8)
[4. Диаграмма](https://github.com/amalkoott/chat_app/edit/master/README.md#4-%D0%B4%D0%B8%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0)

## 1. Требования
![image](https://github.com/user-attachments/assets/1c0ee671-9ead-4dc2-ab19-5c51f2b5ebd5)

## 2. Фреймворки и технологии

Стек: Kotlin, MVVM, Clean Architecture, Jetpack Compose, WebSocket + JSON, Http, Coil, Exoplayer, LruCache, FileCache, Hilt, Room, FCM


Язык - **Kotlin**. Ну тут все понятно.


Состояние чата может меняться быстро (сообщения, статусы и т.д) -> реактивный UI. Из mv-паттернов под реактивность лучше всего заточены mvvm и mvi, они же обеспечивают большую изолированность логики, чем mvp/mvc. 

Я бы выбрала **mvvm**, т.к. он покрывает требования, проще mvi и в целом стандартный и популярный для android. 

Если у команды опыта с mvi больше - логичнее сразу работать на нем, т.к. в дальнейшем при усложнении логики состояние приложения лучше будет контролироваться именно через mvi (хоть изначально паттерн и может оказаться излишним). В случае небольшого опыта с mvi можно итеративно уходить от mvvm, либо комбинировать оба паттерна.

Mvvm хорошо сочетается с Clean Architecture, поэтому не забывает следовать ее прицнипам.


**Jetpack Compose** - для приложения с нуля считаю лучшим выбором:
- UI создаётся быстрее благодаря декларативному подходу, без xml
- Встроенная поддержка state, автоматическая перерисовка ui
- Актуальнее и проще в освоении, чем view


**Material design** - стандарт для Android, предоставляет гайдлайны для проектирования и разработки UI, которые уже частично учитывают что будет удобно для использования, а что точно нет.


**WebSocket** - двухстороннее real-time соединение, подходящее для реализации чатов. В контексте разрабатываемого приложения полезна поддержка отправки текстовых данных (CSV, XML, JSON и т.д.). Поддерживается многими библиотеками и разными платформами, настраивать проще, чем поднимать кастомный tcp.

Для быстрой разработки я бы использовала **JSON**, однако рассмотрела бы использование protobuf в дальнейшем. 

Почему? Насколько знаю, поддерживается google и достаточно легко интегрируется в android + компактнее и быстрее json.
Почему не использовать его сразу? Я только в курсе про существование такого формата, но не работала с ним. Если достоинства pb важнее быстрого подъема аппы, то будем использовать его, закладывая время на изучение работы с форматом. 

Если стек WS + JSON, то используем **OkHttp + Moshi** для парсинга json

Если стек WS + protobuf, то используем тот же OkHttp, но подключаем protobuf-gradle-plugin.

OkHttp легкий, требует мало настроек для быстрого старта, де-факто стандарт для android, поэтому с нуля я бы работала с этой библиотекой. Moshi (если все таки используем json) быстрее gson, это важно, особенно при парсинге больших сообщений + лучше интегрируется с kotlin.


Также надо не забывать, что чат может скроллиться вверх, а загружать абсолютно все сообщения чата - нерационально -> используем пагинацию


Для загрузки вложений используем комбинированный подход:

- **Coil** и **Exoplayer** - загрузка изображений и видео: готовое решение, быстро внедрится
- **HTTP** - загрузка вложений остальных типов  в сообщениях. WS не предназначен для больших файлов, поэтому для вложений будем использовать отдельный get-запрос, http прекрасно для этого подходит. С Okhttp также можно создать клиента, используем его.  


Для пушей используем **FCM** - также стандартное решение для android-устройств. 


Кеширование
Для недавних сообщений - рекомендацией является **LruCache**. Лично с ним не работала, выбрала бы его как минимум из-за объема обучающих материалов и рекомендаций.  
Вложения кешировала бы в виде файлов:
- есть доступ из хранилища
- оптимальнее хранить не в БД
- легче настраивать очистку

**Room** - необходимость выяснила из 3 пункта. Почему Room - стандартное решение для Android.

В будущем для настроек - DataStore (хранение простых данных, современнее SharedPreferences)


Хорошая практика и полезно при масштабировании - внедрение DI. Считаю, что даже для небольших приложений DI нужно использовать, т.к. потом будет проще организовать тесты или заменить компоненты + очень нравится автоматическое подтягивание зависимостей. Использовала бы **Hilt**:
- об ошибках с зависимостями узнаю при компиляции, а не в рантайме (в отличие от Koin)
- много с ним работала, хоть и не на глубоком уровне


## 3. Детали

#### API
**WebScoket**

- Формат сообщения от сервера: { type = <>, ... }
- Формат сообщения от клиента: { action = <>, ... }


Поле action:
- GET_CHATS - запросить список чатов по user_id
- GET_CHAT - загрузить чат по chat_id
- SEND_MESSAGE - отправить сообщение, аргументы user_id и chat_id
- CREATE_CHAT - создать чат для user_id и partner_id
- DELETE_CHAT - удалить чат с chat_id у пользователя user_id
- FIND_CHAT - поиск по части названия чата (или другому значению для поиска)

Поле type:

- CHATS - отправить список чатов - [ chat_id, chat_name, chat_icon, last_message ]
- CHAT - отправить сам чат (одну страницу) - [ chat_id, chat_type, ... ]
- NEW_MESSAGE - отправить новое сообщение message в чате c chat_id 

**HTTP**
- getFile?{file_if} - ручка для загрузки вложения по file_id

#### Общее

Для навигации используем Navigation Compose

Когда приложение в фоне, сервер кидает пуши через FCM -> для чата нужно отслеживание включенных уведомлений.

#### Список чатов

Пусть пользователь зарегистрирован, соединение с сервером установлено -> по  user_id загружаются чаты (action = GET_CHATS), есть два кейса:
- Пришел пустой список 
- Пришел нормальный список

Когда чатов нет, пользователь может создать чат (action = [ CREATE_CHAT | FIND_CHAT ]) -> полученный чат появится у пользователя.

В нашей реализации есть два типа чатов - личные и групповые.
Создание личного чата - это поиск пользователя по какому-либо идентификатору (action = FIND_CHAT)
В групповой чат можно добавиться (action = FIND_CHAT ) или можно его создать ( action = CREATE_CHAT ).

Если чаты есть -> отображается список. Клик на чате (action = GET_CHAT) -> переход на экран чата.

Элемент списка - это превью чата, содержит название, иконку и последнее сообщение, counter (если есть непрочитанные сообщения, type = NEW_MESSAGE). 

По клику переходим в сам чат (action = GET_CHAT)

Свайп влево с perform_click - удаление чата (action = DELETE_CHAT). Действие точно должно отправлять user_id и chat_id. Если говорить про backend, то сам чат (не его сообщения) скорее будет храниться в реляционной БД, поэтому он не пропадет у собеседника.

Чаты в списке отображаются от последних с новым сообщением до самых старых. На первый взгляд достаточно просто реализуемо, т.к. есть сообщения от сервера с type = NEW_MESSAGE.

Экран списка чатов достаточно статичен (не считая только предпросмотра последних сообщений чата) -> кешируем информацию о чате (пока вижу, что можно кешировать chat_id, chat_name, chat_icon). Так немного меньше взаимодействуем с сервером -> меньше расходуем трафик. Т.к. сервер отправляет сообщения с type = NEW_MESSAGE, последнее сообщение чата остается актуальным.

![image](https://github.com/user-attachments/assets/68c7d060-db36-4bcd-b3f5-aeb9ddf73ce6)


#### Экран чата

**Сообщение**

Для групповых и личных чатов нет разницы в структуре сообщения. Сообщение приходит от сервера с type = NEW_MESSAGE, парсится в dto и отображается на экране. В сообщениях могут быть вложения, тогда в extra будут находится file_url этих вложений.

![image](https://github.com/user-attachments/assets/e2bb5d18-e837-4340-bedb-16dec47c56c1)


Их загрузку я бы начинала бы по требованию пользователя, а не при получении сообщения -> меньший расход трафика + ускорение отображения сообщения. 

- Coil/Exoplayer - фото/видео
- отдельным get-запросом для файлов другого типа

В будущем в настройки можно добавить опцию для управления таким поведением

Через Coil и Exoplayer можно задать предпросмотр вложений (фото/видео). Другие форматы особо нет смысла предпросматривать, можно полностью грузить.

Вложения могут быть большие, разных форматов, поэтому кешировать их надо в виде файлов (оптимальнее сохранения в БД). Для файлов также легче настроить логику очистки + к ним есть доступ из хранилища. Сейчас бы сказала, что весь механизм кеширования сделала бы руками - сохранять все вложения в файлы, в Room хранить записи типа <extra_url, path_to_cache>(key,value) для организации логики работы с кешем, но возможно есть и лучшие решения.

![image](https://github.com/user-attachments/assets/d764081c-69f2-4c31-94e2-9cfdbb12a17e)


Опции кеширования вложений:
в зависимости от того, где находится вложение (личка/групповой чат) -> нужен chat_type для чата
размер/формат вложения
как давно было получено вложение

Загрузка данных из кеша
Для сообщения с вложением проверять записи в Room по ключу extra_url и подгружать их в ui для сообщения по параметру path_to_cache.


**Просмотр чата**

При скролле чата вверх, когда изначально загруженная страница закончилась, отправляем новое сообщение action = GET_CHATS с нужным смещением, смещение можно не кешировать. Полученные сообщение добавляем в отображаемые и обновляем UI.


**Ввод и отправка сообщения**

Button рядом с полем ввода сообщения отправляет сообщение на сервер (action = SEND_MESSAGE). Также формируется message-объект, который отображается у нас в ui. Если отправка неудачная - как-то отображаем статус ошибки в ui (возможно предлагаем снова отправить сообщение).


## 4. Диаграмма

![image](https://github.com/user-attachments/assets/e0aa2cf7-7342-4835-a5bd-10ff7c2c099d)
